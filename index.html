<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Puzzle Sat encoding</title>
  <meta name="viewport" content="width=device-width">
  <style media="screen">
  html, body{
    margin: 0;
    padding: 0;
  }
  table{
    margin: 10px auto 0 auto;
  }
  table, td{
    border: 1px solid black;
    border-collapse: collapse;
    text-align: center;
  }
  th, td {
    padding: 5px;
		width: 19px;
		height: 19px;
  }
	.true{
		background: black;
		color: white;
	}
  </style>
</head>
<body>
<div id="container">
</div>
<button type="button" name="button" onclick="solve()">solve</button>
<script type="text/javascript" src="minisat.js"></script>
<script type="text/javascript">
'use strict';
const PUZZLE = [
  ".23..0....",
  "....3.2..6",
  "..5.53.574",
  ".4.5.5.6.3",
  "..4.5.6..3",
  "...2.5....",
  "4.1...11..",
  "4.1...1.4.",
  "....6....4",
  ".44....4.."
];

function Vector(x, y) {
  this.x = x;
  this.y = y;
}
Vector.prototype.plus = function (other) {
  return new Vector(this.x + other.x, this.y + other.y);
};

function Grid(width, height) {
  this.space = new Array(width * height);
  this.width = width;
  this.height = height;
}
Grid.prototype.isInside = function (vector) {
  return vector.x >= 0 && vector.x < this.width && vector.y >= 0 && vector.y < this.height;
};
Grid.prototype.get = function (vector) {
  return this.space[vector.x + this.width * vector.y];
};
Grid.prototype.set = function (vector, value) {
  this.space[vector.x + this.width * vector.y] = value;
};
Grid.prototype.vectorToNumber = function (vector) {
	return vector.x + vector.y * this.width + 1;
};
Grid.prototype.arrNumberGanDo = function(vector) {
	return this.arrVectorGanDo(vector).map(function (e) {	return this.vectorToNumber(e);	}, this);
};
Grid.prototype.arrVectorGanDo = function(vector) {
  var arr = [];
  var temp;
  for(let y = -1; y <= 1; y++){
    for(let x = -1; x <= 1; x++){
      temp = new Vector(vector.x + x, vector.y + y);
      if(this.isInside(temp))
        arr.push(temp);
    }
  }
  return arr;
};
Grid.prototype.CNF = function() {
  var arrCNF = [];
  for(let y = 0; y < this.height; y++){
    for(let x = 0; x < this.width; x++){
      var vector = new Vector(x, y);
      if(typeof this.get(new Vector(x, y)) === 'number'){
        var temp = this.arrNumberGanDo(vector);
        var itnhat, nhieunhat;

        nhieunhat = toHopChapK(temp.map(function (val) { return 0-val; }), this.get(vector) + 1);
        itnhat = toHopChapK(temp, temp.length - this.get(vector) + 1);

        arrCNF = arrCNF.concat(nhieunhat, itnhat);
      }
    }
  }

  return arrCNF;
};

function elementFromChar(ch) {
  if(ch === ".")
    return null;
  return parseInt(ch);
}

function charFromElement(element) {
  if(element === null)
    return " ";
  return element;
}

function Table(map) {
  this.grid = new Grid(map[0].length, map.length);
  map.forEach(function (line, y) {
    for (let x = 0; x < line.length; x++) {
      this.grid.set(new Vector(x, y), elementFromChar(line[x]));
    }
  }, this);
}
Table.prototype.toString = function () {
  var table = document.createElement('table');
  table.setAttribute('id', 'tablePuzzle')

  for(let y = 0; y < this.grid.height; y++) {
    var tbody = document.createElement('tr');

    for (let x = 0; x < this.grid.width; x++) {
      var element = this.grid.get(new Vector(x, y));
      var td = document.createElement('td');

      td.innerHTML = charFromElement(element);
      tbody.appendChild(td);
    }
    table.appendChild(tbody);
  }
  return table;
};
Table.prototype.toStringColors = function (arr) {
	var table = document.createElement('table');
  table.setAttribute('id', 'tablePuzzle');

  for(let y = 0; y < this.grid.height; y++) {
    var tbody = document.createElement('tr');

    for (let x = 0; x < this.grid.width; x++) {
      var element = this.grid.get(new Vector(x, y));
      var td = document.createElement('td');

			//bat dau tu arr[1] vi arr[0] === "SAT"
			if(arr[this.grid.vectorToNumber(new Vector(x, y))] > 0){
				td.className = "true";
			}
      td.innerHTML = charFromElement(element);
      tbody.appendChild(td);
    }
    table.appendChild(tbody);
  }
  return table;
};


function toHopChapK(arr, k) {
  if(k<=1)
    return arr.map(function(cur) { return [cur]; });

  var toHops = [];
  var temp = [];
  for(let i=0; i <= arr.length - k; i++){
    temp = toHopChapK(arr.slice(i+1, arr.length), k-1);
    temp.forEach(function (cur) {
        cur.unshift(arr[i]);
    });
    toHops = toHops.concat(temp);
  }
  return toHops;
}

function encoding() {
  var cnf = table.grid.CNF();
	var string = '';
	for(let i=0; i < cnf.length; i++) {
	    if(typeof cnf[i] === 'number')
	      string += cnf[i] + ' 0\n';
	    else //Array
	      string += cnf[i].join(' ') + ' 0\n';
	}
	// console.log('p cnf ' + table.grid.width * table.grid.height + ' ' + cnf.length + '\n' + string);
	return 'p cnf ' + table.grid.width * table.grid.height + ' ' + cnf.length + '\n' + string;
}
// -------------------------------------------------


function solve() {
	var solve_string = Module.cwrap('solve_string', 'string', ['string', 'int']);
	var outputElem = "";
	var input = encoding();
	var startTime = (new Date()).getTime();
	var result = solve_string(input, input.length);
	var endTime = (new Date()).getTime();
	outputElem += result;
	console.log('CPU time: ' + ((endTime - startTime) / 1000) + 's\n' + outputElem);
	var tableTrueFalse = outputElem.split(" ");
	// tableTrueFalse.shift();
	document.getElementById('container').replaceChild(table.toStringColors(tableTrueFalse), document.getElementById('tablePuzzle'));
}

// HTML
var table = new Table(PUZZLE);
document.getElementById('container').appendChild(table.toString());
</script>
</body>
</html>
